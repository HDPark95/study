# MyBatis SqlSession @Transactional 동작 분석 보고서

## 1. 개요

### 1.1 목적
Spring Framework의 `@Transactional` 어노테이션 유무에 따른 MyBatis SqlSession의 동작 차이를 분석하고 검증한다.

### 1.2 테스트 환경
- **Spring Boot**: 3.5.4
- **MyBatis Spring Boot Starter**: 3.0.3
- **Java**: OpenJDK 24
- **데이터베이스**: MySQL 8.0 (localhost:3306/mybatis_db)
- **MySQL Connector**: mysql-connector-j (latest)
- **테스트 일자**: 2025-08-02

---

## 2. 이론적 배경

### 2.1 @Transactional이 있는 경우
- Spring의 트랜잭션 관리자가 SqlSession 생명주기를 관리
- 하나의 트랜잭션 범위 내에서 동일한 SqlSession 인스턴스 재사용
- 트랜잭션 종료 시점에 자동 커밋/롤백
- 1차 캐시 활용 가능

### 2.2 @Transactional이 없는 경우
- 각 데이터베이스 연산마다 새로운 SqlSession 생성
- 자동 커밋 모드로 동작
- 1차 캐시를 활용할 수 없음 (매번 새로운 SqlSession이므로)
- 개별 연산별 즉시 커밋

---

## 3. 테스트 케이스별 분석

### 3.1 SqlSession 상태 확인

#### 3.1.1 @Transactional 있음
**예상 결과:**
- 트랜잭션 활성화 상태: `true`
- 동일 객체 인스턴스 반환: `true` (1차 캐시)
- SqlSession 재사용: 예상됨

**실제 결과:**
```
[테스트 결과 기입]
```

**분석:**
```
[분석 내용 기입]
```

#### 3.1.2 @Transactional 없음
**예상 결과:**
- 트랜잭션 활성화 상태: `false`
- 동일 객체 인스턴스 반환: `false` (새로운 SqlSession)
- SqlSession 재사용: 안됨

**실제 결과:**
```
[테스트 결과 기입]
```

**분석:**
```
[분석 내용 기입]
```

---

### 3.2 캐시 동작 확인

#### 3.2.1 @Transactional 있음
**예상 결과:**
- 첫 번째 조회: DB에서 데이터 로드
- 두 번째 조회: 1차 캐시에서 데이터 반환
- 동일한 객체 인스턴스: `true`
- 업데이트 후 캐시 무효화 여부 확인

**실제 결과:**
```
[테스트 결과 기입]
```

**분석:**
```
[분석 내용 기입]
```

#### 3.2.2 @Transactional 없음
**예상 결과:**
- 매번 새로운 SqlSession으로 DB 조회
- 동일한 객체 인스턴스: `false`
- 1차 캐시 미적용

**실제 결과:**
```
[테스트 결과 기입]
```

**분석:**
```
[분석 내용 기입]
```

---

### 3.3 수동 SqlSession 관리

#### 3.3.1 autoCommit = true
**예상 결과:**
- 각 연산별 자동 커밋
- 업데이트 즉시 다른 세션에서 변경사항 확인 가능

**실제 결과:**
```
[테스트 결과 기입]
```

#### 3.3.2 autoCommit = false
**예상 결과:**
- 수동 커밋 필요
- 커밋 전까지 다른 세션에서 변경사항 미확인
- 같은 세션 내에서는 변경사항 확인 가능

**실제 결과:**
```
[테스트 결과 기입]
```

**분석:**
```
[분석 내용 기입]
```

---

### 3.4 예외 상황 처리

#### 3.4.1 @Transactional 있음 (롤백 테스트)
**예상 결과:**
- 예외 발생 시 자동 롤백
- 변경사항 모두 취소
- 데이터 일관성 유지

**실제 결과:**
```
[테스트 결과 기입]
```

#### 3.4.2 @Transactional 없음 (커밋 확인)
**예상 결과:**
- 예외 발생 전까지의 변경사항은 커밋됨
- 부분적 데이터 변경 가능성

**실제 결과:**
```
[테스트 결과 기입]
```

**분석:**
```
[분석 내용 기입]
```

---

## 4. 성능 비교

### 4.1 연결 생성 오버헤드
| 구분 | @Transactional 있음 | @Transactional 없음 |
|------|-------------------|-------------------|
| SqlSession 생성 횟수 | [결과 기입] | [결과 기입] |
| 연결 재사용율 | [결과 기입] | [결과 기입] |
| 평균 응답 시간 | [결과 기입] | [결과 기입] |

### 4.2 캐시 효율성 (같은 데이터를 3번 조회하는 경우)
| 구분 | @Transactional 있음 | @Transactional 없음 |
|------|-------------------|-------------------|
| 실제 SQL 실행 횟수 | [결과 기입] | [결과 기입] |
| 캐시에서 반환된 횟수 | [결과 기입] | [결과 기입] |
| 로그에서 확인할 수 있는 정보 | SQL 로그 출력 횟수로 확인 | 매번 SQL 로그 출력 |

---

## 5. 결론 및 권장사항

### 5.1 주요 발견사항
1. **SqlSession 생명주기 관리**
   - [결론 기입]

2. **캐시 동작**
   - [결론 기입]

3. **트랜잭션 일관성**
   - [결론 기입]

4. **성능 차이**
   - [결론 기입]

### 5.2 사용 권장사항

#### 5.2.1 @Transactional 사용을 권장하는 경우
- [ ] 여러 데이터베이스 연산이 하나의 논리적 작업 단위인 경우
- [ ] 데이터 일관성이 중요한 경우
- [ ] 같은 데이터를 반복 조회하는 경우 (캐시 활용)
- [ ] 예외 발생 시 롤백이 필요한 경우

#### 5.2.2 @Transactional 없이 사용해도 되는 경우   
- [ ] 단일 조회 작업만 수행하는 경우 (한 번의 쿼리만 실행)
- [ ] 각 연산이 독립적이고 캐시 효과가 필요 없는 경우
- [ ] 즉시 커밋이 필요한 경우
- [ ] 트랜잭션 오버헤드를 최소화해야 하는 경우

## 6. 부록

### 6.1 테스트 코드 위치
- Service: `src/main/java/project/springmybatis/service/TransactionTestService.java`
- Controller: `src/main/java/project/springmybatis/controller/TransactionTestController.java`
- HTTP 테스트: `test-requests.http`
